# playwright-bdd-wizard

## Description

`playwright-bdd-wizard` is a easy to use TypeScript library designed to simplify Playwright BDD (Behavior-Driven Development) tests by providing a comprehensive set of reusable and flexible common steps. With these steps, you can write test scenarios using human-understandable language, significantly reducing or even avoiding the need for coding at all.

### Example generated by the library:

- **Scenario: Example with google**
   - **When I open "https://www.google.com" page**
   - **And I "type" "playwright" on the keyboard**
   - **And I "press" "Enter" on the keyboard**
   - **Then I verify that "1" element with "playwright.dev" "text" is "visible"**
   - **And I wait "1" seconds**
   - **When I go back in the browser**
   - **Then I verify if URL "contains" "https://www.google.com"**
   - **When I get a part of the URL based on "www.(.*?).com" regular expression and save it as "websiteNameVariable"**
   - **When I "type" "websiteNameVariable" on the keyboard**
   - **Then I verify that "1" element with "websiteNameVariable" "text" is "visible"**
   - **When I "type" " test with playwright-bdd-wizard finished!" on the keyboard**
   - **And I wait "1.5" seconds**
   - **Then I verify that "1" element with "finished!" "text" is "visible"**

These steps encapsulate common interactions and validations within your Playwright tests, allowing you to focus more on defining scenarios in natural language and less on writing and maintaining test automation code.

To add your own tests just create more `.feature` files with your scenarios in the `tests/features` directory. One feature file can contain multiple scenarios.
Remember that the steps has to be build exacly like the in the examples in HOW TO USE section. Words needs to be in the correct order and the parameters needs to be in quotation marks. Every step should start with either Given, When or Then.

If you're runnig your tests using playwright ui runner, remember you need to run the `npx bddgen` command everytime you add or edit a scenario so the playwright runner can pick up the changes.

## Installation Guide

### Step 1: Initialize Playwright Project

If you don’t have a Playwright project yet, you'll need to install it. If you already have it, skip to Step 2.

1. Navigate to an empty directory where you want to store your test project.
2. Initialize Playwright:
    ```sh
    npm init playwright@latest
    ```
3. During the installation, it will ask if you prefer using JavaScript or TypeScript. It is recommended to use TypeScript.
4. It is also preferred to choose the “tests” folder to store your tests.

For more information, visit the [Playwright documentation](https://playwright.dev/docs/intro).

### Step 2: Install `playwright-bdd-wizard`

1. Install the provided version of `playwright-bdd-wizard`:
    ```sh
    npm install github:Exlabs/playwright-bdd-wizard
    ```
    This will create example tests in the `tests/features` directory.

### Step 3: Update Configuration

1. Update playwright `defineConfig()` in your `playwright.config.ts` file, so that the tests are taken from the autogenerated files in the `.features-gen` directory:
    ```ts
      testDir: '.features-gen',
    ```

### Step 4: Running the Tests
  
1. To run the tests, use the following command:
    ```sh
    npx bddgen && npx playwright test --project=chromium --headed
    ```
    This command specify that you want to run it just on chrome in headed mode.

You should now be set up to use the `playwright-bdd-wizard` library in your Playwright BDD tests!



## How to use

### Steps are divided into 4 groups:

1. General Action
2. Click
3. Insert
4. Verify

Every step should start with either Given, When or Then.

### General Action steps:

1. **I open {string} page**
   - Under the {string}, you can put:
     - an URL that starts with “http”/”https”
     - a process variable you've saved before
     - an URL name from URLs you have saved. How to set up test data, which can be used by `playwright-bdd-wizard` steps, will be described later.
    - Examples:
     - When I open "https://www.google.com" in the browser
     - When I open "savedUrl in the browser

2. **I go back in the browser**
   - Just go back in the browser.

3. **I save the current URL as {string}**
   - Similar to step 1, but it doesn’t use a regular expression, just saves the whole URL.
   - Example:
    - When I save the current URL as "savedUrl


4. **I zoom to {string} in the browser**
   - Zooms in or out in the browser.
   - Example:
     - Then I zoom to "0.5" in the browser

5. **I reload the page**
   - Just reloads the page in the browser.

6. **I wait {string} seconds**
   - Makes the test wait for a given amount of seconds. Works with milliseconds also.
   - Example:
     - Then I wait "1" seconds

7. **I wait for the page to load**
   - Uses `await this.page.waitForLoadState('load')` but also uses `playwright-bdd-wizard` function to wait for the loading messages to disappear. How to set up test data loading messages will be described later.

8. **I get a part of the URL based on {string} regular expression and save it as {string}**
   - Under the first {string}, you put your regular expression based on which you want to receive a string taken from the browser's URL. The second {string} will be a name for your env.process variable, which you can then reuse in other steps.
   - Examples:
     - When I get a part of the URL based on "https:\/\/www\.(.*?)\.com" regular expression and save it as "websiteNameVariable"
     - When I "type" "websiteNameVariable" on the keyboard
     - Then I verify that "1" element with "websiteNameVariable" "text" is "visible"

9. **I {string} {string} on the keyboard**
   - It types a given text on the keyboard or types a text taken from a saved process variable. It can also press keys from the keyboard.
   - Examples:
     - Then I "press" "Enter" on the keyboard
     - Then I "type" "Some text" on the keyboard
     - Then I "type" "previouslySavedVariable" on the keyboard


### Click Actions:

1. **I {string} the {string} element that contains {string}**
   - First {string} defines the type of click you want to perform. Available types of clicks: 'click' | 'dispatch click' | 'force click' | 'force dispatch click'
   - Second {string} defines the type of element you want to click.
   - Third {string} defines a text that the element you want to click should contain.
   - Example:
     - Then I "click" the "button" element that contains "save"

2. **I {string} the {string} element with {string} {string}**
   - First {string} defines the type of click you want to perform. Available types of clicks: 'click' | 'dispatch click' | 'force click' | 'force dispatch click'
   - Second {string} defines which element you want to click. Can be multiple similar elements on the page so you should define if you want to click the first, second, third, and so on.
   - Third {string} defines the text used to locate the element.
   - Fourth {string} defines how you want to locate it. Available ways to locate are: 'text' | 'label' | 'placeholder' | 'role' | 'test ID' | 'alternative text' | 'title' | 'locator'
   - Examples:
     - When I "click" the "1" element with "Save and Refresh" "text"
     - When I "force click" the "3" element with "exit" "label"
     - When I "force click" the "3" element with "[class^='class-name']" "locator"


## Insert Actions:

1. **I fill {string} into the {string} dropdown**
   - It chooses a given text in a dropdown located by dropdown's label.
   - Example:
     - Then I fill "United Kingdom" into the "Country" dropdown

2. **I {string} {string} in the {string} element with {string} {string}**
   - It can type, fill, or choose data into a given UI element.
   - First {string} defines the type of action you want to do: 'type' | 'fill' | 'choose'
   - Second {string} defines the text you want to use.
   - Third {string} defines which element you want to interact with. Can be multiple similar elements on the page so you should define if you want to interact with the first, second, third, and so on.
   - Fourth {string} defines the text used to locate the element.
   - Fifth {string} defines how you want to locate it. Available ways to locate are: 'text' | 'label' | 'placeholder' | 'role' | 'test ID' | 'alternative text' | 'title' | 'locator'
   - Examples:
     - When I "type" "United Kingdom" in the "1” element with "Country" "label"
     - When I "choose" "United Kingdom" in the "2" element with "Country dropdown" "label"
     - When I "type" "United Kingdom" in the "3" element with "Type country" "placeholder"


## Verify Actions:

1. **I verify if a new tab which URL {string} {string} opens**
   - It verifies if a new browser tab opens with a specified URL.
   - First {string} defines the assertion type. Can be: 'contains' | 'doesntContain' | 'equals'
   - Second {string} defines what it should be asserted against. Can be any text, a saved URL name, or a saved process variable.
   - Examples:
     - Then I verify if a new tab which URL "contains" "mySavedVariable" opens
     - Then I verify if a new tab which URL "equals" "https://www.google.com" opens
     - Then I verify if a new tab which URL "doesntContain" "landingPageUrl" opens

2. **I verify if URL {string} {string}**
   - It verifies the current page URL.
   - First {string} defines the assertion type. Can be: 'contains' | 'doesntContain' | 'equals'
   - Second {string} defines what it should be asserted against. Can be any text, a saved URL name, or a saved process variable.
   - Examples:
     - Then I verify if URL "contains" "mySavedVariable" opens
     - Then I verify if URL "equals" "https://www.google.com" opens
     - Then I verify if URL "doesntContain" "landingPageUrl" opens

3. **I verify that a {string} element with {string} text {string} visible**
   - It verifies if a given element is visible or not.
   - First {string} defines which element you want to interact with. Can be multiple similar elements on the page so you should define if you want to interact with the first, second, third, and so on.
   - Second {string} defines the type of element you want to interact with.
   - Third {string} defines if you are doing a positive or negative assertion. Can be: "is" | "is not"
   - Examples:
     - Then I verify that a "button" element with "Save" text "is" visible
     - Then I verify that a "h2" element with "Wrong page title" text "is not" visible

4. **I verify that {string} element with {string} {string} is {string}**
   - It verifies the state of a given element.
   - First {string} defines which element you want to interact with. Can be multiple similar elements on the page so you should define if you want to interact with the first, second, third, and so on.
   - Second {string} defines the text used to locate the element. Can also be a saved process variable.
   - Third {string} defines how you want to locate it. Available ways to locate are: 'text' | 'label' | 'placeholder' | 'role' | 'test ID' | 'alternative text' | 'title' | 'locator'
   - Fourth {string} defines the state you are expecting. Available states: 'visible' | 'hidden' | 'editable' | 'disabled' | 'enabled' | 'read-only'
   - Examples:
     - Then I verify that "1" element with "User password" "label" is "visible"
     - Then I verify that "1" element with "savedText" "text" is "hidden"
     - Then I verify that "1" element with "button" "role" is "disabled"

5. **I verify that {string} element with {string} {string} becomes {string} during {string} seconds**
   - It verifies if a given element gets a given state in a specified amount of time.
   - Examples:
     - Then I verify that "1" element with "Save" "text" becomes "visible" during "5" seconds
     - Then I verify that "1" element with "Exit" "role" becomes "hidden" during "2" seconds
